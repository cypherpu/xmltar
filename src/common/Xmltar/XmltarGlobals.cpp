/*
 * XmltarGlobals.cpp
 *
 *  Created on: Dec 14, 2019
 *      Author: dbetz
 */

#include "Xmltar/XmltarGlobals.hpp"
#include "Xmltar/XmltarMemberCreate.hpp"
#include "Generated/Utilities/Glob.hpp"
#include "Generated/Utilities/IsPrefixPath.hpp"

XmltarGlobals::XmltarGlobals()
	: current_xmltar_file_name_(), current_volume_(),
	  invocationTime_(time(nullptr)), resultCode_(0), errorMessages_() {

	if (options_.starting_volume_)
		current_volume_=options_.starting_volume_.get();
}

/**
 * The files generated by the command-line globs will be archived in lexical order.
 *
 * If --listed-incremental is chosen, then
 * -if a file to be included is missing from the incremental file, it will be added.
 * -if a file to be included is present in the incremental file, and there is no
 *  lower level entry for this file, it will be added.
 * -if a file is already present in the incremental file, and there is a lower level
 *  entry for this file, and the file differs from the next lower level entry,
 *  the file will be added
 * -if a file is already present in the incremental file, and there is a lower level
 *  entry for this file, and the file is the same as the next lower level entry,
 *  the file will be skipped
 * -if the file is present in the incremental file at the next lower level,
 *  but is missing from the filesystem, a delete event will be added to the
 *  incremental file
 */

void XmltarGlobals::NextMemberAux(std::filesystem::path filepath){
	std::cerr << "NextMember=" << filepath << std::endl;
	std::filesystem::file_status f_stat=std::filesystem::symlink_status(filepath);

	if (std::filesystem::is_directory(f_stat)){
		for(auto & p : std::filesystem::directory_iterator(filepath) ){
			filesToBeIncluded_.push(p);
		}
	}

	nextMember_.reset(new XmltarMemberCreate(*this,filepath));
}

void XmltarGlobals::NextMember(){
	std::cerr << "XmltarArchive::NextMember(): entering" << std::endl;
	nextMember_.reset(nullptr);

	std::filesystem::path filepath;

	/*
	 * Cases for snapshot file present:
	 * 1. snapshot files empty, include files not empty
	 *    -process remaining file entries
	 * 2. snapshot files not empty, include files empty
	 *    - check if match include globs
	 *      - match: if not marked deleted, update as deleted
	 *      - no match: copy over
	 * 3. snapshot files not empty, include files not empty
	 *    - if snapshot<include, check if snapshot matches include globs
	 *      - match: if not marked deleted, update as deleted
	 *      - no match: copy over
	 *    - if snapshot>include, add new file entry
	 *    - if snapshot==include, update if changed
	 */

	if (snapshot_){
		for(;;){
			if (snapshot_->fileEntries_.empty())
				snapshot_->ReplenishFileEntries();

			if (snapshot_->fileEntries_.empty())
				if (filesToBeIncluded_.empty())
					return;
				else // !filesToBeIncluded_.empty()
					break;
			else { // !snapshot_->fileEntries_.empty()
				if (filesToBeIncluded_.empty()){
					for( ; !snapshot_->fileEntries_.empty(); snapshot_->ReplenishFileEntries()){
						if (IncludedFile(snapshot_->fileEntries_.front().pathname_)
							&& !ExcludedFile(snapshot_->fileEntries_.front().pathname_)
							&& snapshot_->fileEntries_.front().LastAction(options_.dump_level_.get())!="deleted"){
							snapshot_->fileEntries_.front().snapshotEvents_.push_back(
								SnapshotEvent(
									invocationTime_,
									options_.dump_level_.get(),
									"del",
									"",
									0,
									0,
									""
								)
							);
							snapshot_->CopyFrontFileEntryAndPop();
						}
						else {
							snapshot_->CopyFrontFileEntryAndPop();
						}
					}
				}
				else { // !filesToBeIncluded_.empty()
					if (snapshot_->fileEntries_.front().pathname_<filesToBeIncluded_.top()){
						if (IncludedFile(snapshot_->fileEntries_.front().pathname_)
							&& ExcludedFile(snapshot_->fileEntries_.front().pathname_)
							&& snapshot_->fileEntries_.front().LastAction(options_.dump_level_.get())!="delete"){
							snapshot_->fileEntries_.front().snapshotEvents_.push_back(
								SnapshotEvent(
									invocationTime_,
									options_.dump_level_.get(),
									"delete",
									"",
									0,
									0,
									""
								)
							);
							snapshot_->CopyFrontFileEntryAndPop();
						}
						else {
							snapshot_->CopyFrontFileEntryAndPop();
						}
					}
					else if (snapshot_->fileEntries_.front().pathname_>filesToBeIncluded_.top()){
						if (!ExcludedFile(snapshot_->fileEntries_.front().pathname_)){
							filepath=filesToBeIncluded_.top();
							filesToBeIncluded_.pop();
							NextMemberAux(filepath);
							return;
						}
						else {
							filesToBeIncluded_.pop();
						}
					}
					else { // snapshot_->fileEntries_.front()==filesToBeIncluded_.top()
						if (ExcludedFile(snapshot_->fileEntries_.front().pathname_)){
							snapshot_->CopyFrontFileEntryAndPop();
							filesToBeIncluded_.pop();
						}
						else {
							if (snapshot_->fileEntries_.front().LastAction(options_.dump_level_.get())=="deleted"){
								/*
								 * this file is present, but marked as deleted
								 * add it to the incremental file list
								 */
								filepath=filesToBeIncluded_.top();
								filesToBeIncluded_.pop();
								NextMemberAux(filepath);
								return;
							}
							else {
								/*
								 * this file is present in both file entries and the fs
								 * update it if changed
								 */
							}
						}
					}
				}
			}
		}
	}

	for(;;){
		if (filesToBeIncluded_.empty()){
			return;
		}
		else if (filesToBeExcluded_.empty()){
			filepath=filesToBeIncluded_.top();
			filesToBeIncluded_.pop();
			NextMemberAux(filepath);
			return;
		}
		else if (filesToBeIncluded_.top()==filesToBeExcluded_.top()){
			filesToBeIncluded_.pop();
			filesToBeExcluded_.pop();
		}
		else if (filesToBeIncluded_.top()>filesToBeExcluded_.top()){
			filesToBeExcluded_.pop();
		}
		else {
			filepath=filesToBeIncluded_.top();
			filesToBeIncluded_.pop();
			NextMemberAux(filepath);
			return;
		}
	}
}
